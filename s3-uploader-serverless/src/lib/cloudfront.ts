/**
 * cloudfront.ts
 *
 * Implementation using @aws-sdk/cloudfront-signer.
 * This module exports a small wrapper that calls the SDK signer and returns
 * a normalized shape:
 *   { policy?: string, signature?: string, keyPairId: string, expiresAt: number }
 *
 * Notes:
 * - `resource` is passed as `url` to the signer and `dateLessThan` is set to the
 *   computed expiresAt (epoch seconds). This produces signed cookies suitable
 *   for CloudFront.
 * - The wrapper uses named import (ES import) per project TS config.
 */

import { getSignedCookies as sdkGetSignedCookies } from "@aws-sdk/cloudfront-signer";

/**
 * Build a custom policy JSON for CloudFront that expires at a given epoch time.
 * This yields a "CloudFront-Policy" value in the SDK output (unlike canned policy).
 */
const makePolicy = (resource: string, expiresAtEpochSeconds: number) => {
  const policy = {
    Statement: [
      {
        Resource: resource,
        Condition: {
          DateLessThan: { "AWS:EpochTime": expiresAtEpochSeconds },
        },
      },
    ],
  };
  return JSON.stringify(policy);
};

/**
 * Create CloudFront signed cookie values (not full Set-Cookie headers).
 *
 * Uses a custom policy so the returned output includes "CloudFront-Policy".
 *
 * @param resource   e.g. "https://cdn.file-manager.emisa.me/*" or with a path prefix
 * @param expiresInSeconds  lifetime from now, in seconds
 * @param keyPairId  Public key ID (or Key Pair ID)
 * @param privateKeyPem PEM private key matching the public key
 */
export const getSignedCookies = (
  resource: string,
  expiresInSeconds: number,
  keyPairId: string,
  privateKeyPem: string
): { policy?: string; signature?: string; keyPairId: string; expiresAt: number } => {
  // Use a fixed 1 day expiration (24 hours).
  const ONE_DAY_SECONDS = 24 * 60 * 60;
  // Keep the parameter referenced so TS no-unused-params doesn't complain.
  void expiresInSeconds;
  const expiresAt = Math.floor(Date.now() / 1000) + ONE_DAY_SECONDS;
  const trace = { resource, keyPairId, expiresInSeconds: ONE_DAY_SECONDS, expiresAt };

  // Build custom policy (this instructs the signer to return CloudFront-Policy)
  const policyString = makePolicy(resource, expiresAt);

  try {
    // Call the SDK with the custom policy. The SDK will return the cookie map.
    const out = sdkGetSignedCookies({
      policy: policyString,
      keyPairId,
      privateKey: privateKeyPem,
    });

    // SDK returns keys like:
    // { "CloudFront-Key-Pair-Id": "...", "CloudFront-Signature": "...", "CloudFront-Policy": "...", "CloudFront-Expires": 1234567890 }
    const policy = out["CloudFront-Policy"];
    const signature = out["CloudFront-Signature"];
    const resolvedKeyPairId = out["CloudFront-Key-Pair-Id"] || keyPairId;
    const expiresAtReturned = out["CloudFront-Expires"] ? Number(out["CloudFront-Expires"]) : expiresAt;

    console.debug("[cloudfront] signed cookies generated by @aws-sdk/cloudfront-signer (custom policy)", { out });

    return {
      policy,
      signature,
      keyPairId: resolvedKeyPairId,
      expiresAt: expiresAtReturned,
    };
  } catch (err) {
    console.error("[cloudfront] @aws-sdk/cloudfront-signer failed to sign cookies", {
      message: err instanceof Error ? err.message : String(err),
      trace,
    });
    throw err;
  }
};
